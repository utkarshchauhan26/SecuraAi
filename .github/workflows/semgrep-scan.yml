# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: SecuraAI Scan

on:
  repository_dispatch:
    types: [scan-request]
  workflow_dispatch:
    inputs:
      scan_id:
        description: 'Scan ID from database'
        required: true
        type: string
      project_path:
        description: 'Path to project files'
        required: true
        type: string
      scan_type:
        description: 'Scan type (fast or deep)'
        required: false
        default: 'fast'
        type: choice
        options:
          - fast
          - deep

jobs:
  semgrep-scan:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Semgrep
        run: |
          python -m pip install --upgrade pip
          pip install semgrep==1.88.0
      
      - name: Download project files from workflow dispatch
        if: github.event_name == 'workflow_dispatch'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          echo "Scan ID: ${{ github.event.inputs.scan_id }}"
          echo "Project path: ${{ github.event.inputs.project_path }}"
          echo "Scan type: ${{ github.event.inputs.scan_type }}"
          mkdir -p scan_workspace
      
      - name: Process repository dispatch event
        if: github.event_name == 'repository_dispatch'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          SCAN_ID: ${{ github.event.client_payload.scan_id }}
        run: |
          echo "‚úÖ Repository dispatch event received"
          echo "Scan ID: ${{ github.event.client_payload.scan_id }}"
          echo "Repo URL: ${{ github.event.client_payload.repo_url }}"
          echo "Scan type: ${{ github.event.client_payload.scan_type }}"
          echo "User ID: ${{ github.event.client_payload.user_id }}"
          
          # Update scan status to 'running'
          python3 << 'EOF'
          import json
          import os
          from urllib.request import Request, urlopen
          from urllib.error import HTTPError
          
          scan_id = os.environ.get('SCAN_ID')
          supabase_url = os.environ.get('SUPABASE_URL')
          supabase_key = os.environ.get('SUPABASE_SERVICE_KEY')
          
          scan_update = {
              'status': 'running',
              'progress': 10
          }
          
          headers = {
              'apikey': supabase_key,
              'Authorization': f'Bearer {supabase_key}',
              'Content-Type': 'application/json',
              'Prefer': 'return=minimal'
          }
          
          data = json.dumps(scan_update).encode('utf-8')
          req = Request(
              f'{supabase_url}/rest/v1/scans?id=eq.{scan_id}',
              data=data,
              headers=headers,
              method='PATCH'
          )
          
          try:
              with urlopen(req) as response:
                  print(f"‚úÖ Updated scan {scan_id} status to 'running'")
          except HTTPError as e:
              print(f"‚ö†Ô∏è Failed to update scan status: {e.code} {e.reason}")
          EOF
          
          mkdir -p scan_workspace
          
          # Clone the repository if URL provided
          REPO_URL="${{ github.event.client_payload.repo_url }}"
          if [ -n "$REPO_URL" ] && [ "$REPO_URL" != "null" ]; then
            echo "üì• Cloning repository: $REPO_URL"
            cd scan_workspace
            if git clone --depth 1 "$REPO_URL" project; then
              echo "‚úÖ Repository cloned successfully"
              ls -la project/
            else
              echo "‚ùå Failed to clone repository"
              exit 1
            fi
            cd ..
          else
            echo "‚ö†Ô∏è No repository URL provided - scan will fail"
            exit 1
          fi
      
      - name: Run Semgrep Fast Scan
        if: |
          (github.event_name == 'workflow_dispatch' && github.event.inputs.scan_type == 'fast') ||
          (github.event_name == 'repository_dispatch' && github.event.client_payload.scan_type == 'fast')
        run: |
          # Use local fast scan rules (NO internet downloads, NO rate limits)
          semgrep scan \
            --config=backend/config/fast-scan-rules.yaml \
            --json \
            --output=semgrep-results.json \
            --metrics=off \
            --disable-version-check \
            --no-git-ignore \
            --timeout=300 \
            --max-memory=2000 \
            scan_workspace/ || true
      
      - name: Run Semgrep Deep Scan
        if: |
          (github.event_name == 'workflow_dispatch' && github.event.inputs.scan_type == 'deep') ||
          (github.event_name == 'repository_dispatch' && github.event.client_payload.scan_type == 'deep')
        run: |
          # Use local rules for deep scan to avoid rate limits
          semgrep scan \
            --config=backend/config/fast-scan-rules.yaml \
            --json \
            --output=semgrep-results.json \
            --metrics=off \
            --disable-version-check \
            --no-git-ignore \
            --timeout=600 \
            --max-memory=2000 \
            scan_workspace/ || true
      
      - name: Upload results to Supabase
        if: always()
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          SCAN_ID: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.scan_id || github.event.client_payload.scan_id }}
        run: |
          python3 << 'EOF'
          import json
          import os
          import sys
          from urllib.request import Request, urlopen
          from urllib.error import HTTPError
          
          # Read Semgrep results
          try:
              with open('semgrep-results.json', 'r') as f:
                  results = json.load(f)
          except FileNotFoundError:
              print("No Semgrep results file found")
              results = {"results": [], "errors": []}
          
          scan_id = os.environ.get('SCAN_ID')
          supabase_url = os.environ.get('SUPABASE_URL')
          supabase_key = os.environ.get('SUPABASE_SERVICE_KEY')
          
          print(f"üîç Environment check:")
          print(f"  SCAN_ID: {'‚úÖ Set' if scan_id else '‚ùå Missing'}")
          print(f"  SUPABASE_URL: {'‚úÖ Set' if supabase_url else '‚ùå Missing'}")
          print(f"  SUPABASE_SERVICE_KEY: {'‚úÖ Set' if supabase_key else '‚ùå Missing'}")
          
          if not all([scan_id, supabase_url, supabase_key]):
              print("‚ùå Missing required environment variables")
              print(f"   SCAN_ID: {scan_id}")
              print(f"   SUPABASE_URL: {supabase_url[:30] + '...' if supabase_url else 'None'}")
              print(f"   SUPABASE_SERVICE_KEY: {supabase_key[:20] + '...' if supabase_key else 'None'}")
              sys.exit(1)
          
          print(f"‚úÖ All environment variables set")
          print(f"   Processing scan: {scan_id}")
          
          # Process findings
          findings = []
          for result in results.get('results', []):
              # Map severity
              severity_map = {
                  'ERROR': 'CRITICAL',
                  'WARNING': 'HIGH',
                  'INFO': 'MEDIUM'
              }
              raw_severity = result.get('extra', {}).get('severity', 'INFO').upper()
              severity = severity_map.get(raw_severity, 'MEDIUM')
              
              finding = {
                  'scan_id': scan_id,
                  'rule_id': result.get('check_id', 'unknown'),
                  'severity': severity,
                  'title': result.get('extra', {}).get('metadata', {}).get('message', result.get('check_id', 'Unknown Issue')),
                  'message': result.get('extra', {}).get('message', 'No message'),
                  'file_path': result.get('path', 'unknown'),
                  'start_line': result.get('start', {}).get('line', 0),
                  'end_line': result.get('end', {}).get('line', 0),
                  'code_snippet': result.get('extra', {}).get('lines', ''),
                  'category': result.get('extra', {}).get('metadata', {}).get('category', 'security'),
                  'cwe': result.get('extra', {}).get('metadata', {}).get('cwe', []),
                  'owasp': result.get('extra', {}).get('metadata', {}).get('owasp', [])
              }
              findings.append(finding)
          
          # Upload findings to Supabase
          if findings:
              headers = {
                  'apikey': supabase_key,
                  'Authorization': f'Bearer {supabase_key}',
                  'Content-Type': 'application/json',
                  'Prefer': 'return=minimal'
              }
              
              data = json.dumps(findings).encode('utf-8')
              req = Request(
                  f'{supabase_url}/rest/v1/findings',
                  data=data,
                  headers=headers,
                  method='POST'
              )
              
              try:
                  with urlopen(req) as response:
                      print(f"‚úÖ Uploaded {len(findings)} findings to Supabase")
              except HTTPError as e:
                  print(f"‚ùå Failed to upload findings: {e.code} {e.reason}")
                  sys.exit(1)
          else:
              print("No findings to upload")
          EOF
      
      - name: Set up Node.js for PDF generation
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install PDF dependencies
        run: |
          cd backend
          npm install pdfkit
      
      - name: Generate PDF Report
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          SCAN_ID: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.scan_id || github.event.client_payload.scan_id }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          (async () => {
            try {
              // Load PDF service
              const pdfServicePath = path.join(process.cwd(), 'backend/services/pdf-report.service.js');
              
              if (!fs.existsSync(pdfServicePath)) {
                console.log('‚ùå PDF service not found at:', pdfServicePath);
                fs.writeFileSync('report-info.json', JSON.stringify({ filePath: null, fileName: null }));
                return;
              }
              
              const PDFService = require(pdfServicePath);
              const pdfService = new PDFService();
              
              const scanId = process.env.SCAN_ID;
              
              console.log('üìÑ Generating PDF report for scan:', scanId);
              
              const result = await pdfService.generateScanReport(scanId, null);
              
              console.log('‚úÖ PDF generated:', result.fileName);
              console.log('   File path:', result.filePath);
              console.log('   File size:', (result.size / 1024).toFixed(2), 'KB');
              
              // Save report path for next step
              fs.writeFileSync('report-info.json', JSON.stringify({
                filePath: result.filePath,
                fileName: result.fileName
              }));
            } catch (err) {
              console.error('‚ùå PDF generation failed:', err.message);
              console.error(err.stack);
              console.log('‚ö†Ô∏è  Continuing without PDF report');
              // Write empty info to prevent next step from failing
              fs.writeFileSync('report-info.json', JSON.stringify({
                filePath: null,
                fileName: null
              }));
            }
          })();
          EOF
      
      - name: Upload PDF to Supabase Storage
        if: always()
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          SCAN_ID: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.scan_id || github.event.client_payload.scan_id }}
        run: |
          # Check if PDF was generated
          if [ ! -f "report-info.json" ]; then
            echo "‚ö†Ô∏è  No report info found, skipping upload"
            exit 0
          fi
          
          FILE_PATH=$(node -p "JSON.parse(require('fs').readFileSync('report-info.json')).filePath")
          FILE_NAME=$(node -p "JSON.parse(require('fs').readFileSync('report-info.json')).fileName")
          
          if [ "$FILE_PATH" = "null" ] || [ ! -f "$FILE_PATH" ]; then
            echo "‚ö†Ô∏è  PDF file not found, skipping upload"
            exit 0
          fi
          
          echo "üì§ Uploading PDF to Supabase Storage..."
          
          # Upload file to Supabase Storage using REST API
          BUCKET_NAME="reports"
          STORAGE_PATH="$SCAN_ID/$FILE_NAME"
          
          curl -X POST \
            "$SUPABASE_URL/storage/v1/object/$BUCKET_NAME/$STORAGE_PATH" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
            -H "Content-Type: application/pdf" \
            --data-binary "@$FILE_PATH" \
            -w "\nHTTP Status: %{http_code}\n"
          
          # Get public URL
          PUBLIC_URL="$SUPABASE_URL/storage/v1/object/public/$BUCKET_NAME/$STORAGE_PATH"
          echo "‚úÖ Report uploaded to: $PUBLIC_URL"
          
          # Update scan record with report URL
          python3 << PYEOF
          import json
          import os
          from urllib.request import Request, urlopen
          from urllib.error import HTTPError
          
          scan_id = os.environ.get('SCAN_ID')
          supabase_url = os.environ.get('SUPABASE_URL')
          supabase_key = os.environ.get('SUPABASE_SERVICE_KEY')
          public_url = os.environ.get('PUBLIC_URL', f"{supabase_url}/storage/v1/object/public/reports/{scan_id}/$FILE_NAME")
          
          scan_update = {
              'report_url': public_url
          }
          
          headers = {
              'apikey': supabase_key,
              'Authorization': f'Bearer {supabase_key}',
              'Content-Type': 'application/json',
              'Prefer': 'return=minimal'
          }
          
          data = json.dumps(scan_update).encode('utf-8')
          req = Request(
              f'{supabase_url}/rest/v1/scans?id=eq.{scan_id}',
              data=data,
              headers=headers,
              method='PATCH'
          )
          
          try:
              with urlopen(req) as response:
                  print(f"‚úÖ Updated scan with report URL: {public_url}")
          except HTTPError as e:
              print(f"‚ö†Ô∏è Failed to update scan with report URL: {e.code} {e.reason}")
          PYEOF
      

      
      - name: Cleanup
        if: always()
        run: |
          rm -rf scan_workspace
          rm -f semgrep-results.json
